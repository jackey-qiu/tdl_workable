/******************************************************************************
* Interface to lmdif for generic least-squares fitting
* 
* Authors/modifications
* ---------------------
* - T. Trainor, 4-02-03
*
*
* Notes
* -----
* This module provides an interface to the lmdif non-linear least squares 
* routine defined in lmdif.c.  The data structure FitData defined in the 
* header should hold all the information needed for modeling/fitting.
* 
* This interface allows for simple parameter linking and updates to the 
* fit parameters, ranges etc.. The essential steps invloved in using this 
* package is to:
*
* - Define a 'model' function.  It should be defined using the protype:
*   iflag = func(double *x, int num_x, double *ycalc, int num_ycalc, TYPE *farg)
*   - x is the array of independant variables (lenght num_x). Note that
*     num_x = 0 is valid.
*   - ycalc is an array for the resulting calc (length num_ycalc)
*     Note that ycalc is used in the sum-of-squares computation of chi_squr. 
*     ycalc may differ in length from x but must have at least one element.  
*     More details below.
*   - farg is a pointer to additional function arguments (variables and
*     and other data specific to the function). This will generally be
*     a user defined structure or array etc... (type = TYPE) 
*   - iflag is a return code. The func shoud return <0 to specify an error
*
* - Create a FitData instance using the init_fit() function below. E.g
*   fit = init_fit(my_function, 0, function_arg, "my function")
* 
* - Setup the fitting parameters. The convention used here is as follows.  
*   The fitting parameters (ie what gets adjust by the least-squares routine) 
*   are the values in the 'del' array in the FitData structure. 
*   The del's (deltas) are used to adjust the model variables that 
*   are linked to them via:
*
*     variable_i = variable_i_0 + scale_i * del_j
*
*   Using this convention we can easily link the adjustment of several variables
*   using a single del_j.  We can have as many del values as we want, but it is
*   important of course that a variable is only linked to one del. 
*    
*   The del values can also be constrained in the fit using dmin/dmax values, 
*   and we can them turn off/on in the fit using the float_idx array.  
*   See set_fit_param(). Set the fit->check_plim flag .    
*
*   To create a new fit parameter use the new_fit_param() function or the 
*   set_fit_param() function.  These will create/exapand all the arrays associated 
*   with a fit parameter (del, del_err, dmin, dmax, float_idx, param_map) 
*
*   To set/edit the fit parameter data use set_fit_param()
*
* - To link a model variable to a specific fit parameter use the link_fit_var()
*   function.  Note that this takes as an argument the pointer to the variable.
*   Therefore the variable may exist anywhere (as long as its in scope during the
*   calculation) - best practice is that it exists in farg.  Note also the variable
*   must be a double precision number.  
*
*   It is the callers responsibilty to keep track of the index numbers of 
*   the fit parameters and what variables are linked to them.  
*
* - Add data to the FitData structure.  Use update_fit_data().  Note that none of 
*   the functions here do not modify any of the user supplied data (xdat, 
*   ydat, yerr).  It is the users responsibilty to create and destroy these arrays. 
*   NULL values are valid for all the arrays.  If n_dat > 0 then any of these arrays
*   that is not NULL must be of length n_dat.  
*
* - Do the fit (or calculation).  Use the do_fit() function.  
*
*   The 'model' function updates the array fit->ycalc
*   which has a length fit->n_ycalc. The fit->ycalc array (and fit->residual 
*   array) are generated by _update_fit_ycalc() using:  
*      fit->n_ycalc = fit->n_dat     : if fit->n_ret = 0 
*      fit->n_ycalc = fit->n_dat + 1 : if fit->n_ret = 1 etc. 
*      fit->n_ycalc = 1              : if fit->n_ret = -1 etc. 
*   where fit->n_dat is the length of fit->xdat (if not NULL), 
*   fit->ydat (if not NULL), and fit->yerr (if not NULL). Note 
*   that fit->n_dat = 0.  
* 
*   - If fit->ydat is NULL or fit->n_ret < 0 the residual are the 
*     ycalc values
*
*   - If fit->n_ret == 0 the residual is computed from the differences between 
*     model and the data (and scaled by 1/sqrt(yerr) if yerr is not NULL)
*
*   - If n_ret > 0, then the first fit->n_dat values are calc as above.  
*     The additional n_ret values are simply the additional ycalc values.  

*   See _func_call() for more info.
*
*   Note to toggle limit checking use fit->check_plims flag (default is TRUE).  
*   These are hard wall limits.  If a fit parameter hits a limit the fit 
*   (and fit errors) should be suspect since we will likely not be at a real 
*   local minimum. If dmin = dmax for a particular parameter there will be no 
*   limit checking for that parameter even in the fit->check_plims = TRUE
*
* - To get/display results see:
*   - get_fit_stats()
*   - get_fit_ycalc()
*   - get_fit_resid()
*   - get_fit_params()
*   - get_fit_param_errs()
*   - show_fit()
*
* - If you would like to update the model parameters to the best fit values
*   use accept_fit_params().  This sets your variable values using the best
*   fit del's and resets the dels (and del_err's) to zeros.  Therefore, any
*   subsequent fit will be doen with respect to the updated variables.
*
* - When you are finished use clear_fit() to free all the memory associated
*   with the fit.  Note this will not free memory associated with xdat,ydat or yerr.
*   Also note in the above 'output' functions which/when these will make copies 
*   or return pointers...
* 
* Todo
* ----
* Add:
*  - unlink_fit_var() 
*  - del_fit_param() 
* 
* Also should we allow passing strings to link_fit_var() to name the 
* parameter?  Then we can search and find the (param_index, link_index)
* values.  This might be useful for unlink_fit_var() methods and 
* in a get_fit_vars (ie compute a list of var values and errors and 
* have them correlated with a string array of variable names).
*
******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include <utils/utils.h>
#include <fit/fit.h>
#include <fit/lmdif.h>

// local protypes and defs
int _update_fit_ycalc(FitData_t *fit);
int _update_fit_vars(FitData_t *fit);
int _reset_fit_vars(FitData_t *fit);
int _func_call(int num_ycalc, int num_free_params, 
               double *free_params, double *resid,
               void   *fit_data);

/******************************************************************************
* init_fit()
* Create a new fit structure
*
* Parameters
* ---------
* - func: pointer to the fitting model function.  func should have a prototype:
*    iflag = func(double *x, int num_x, double *ycalc, int num_ycalc, TYPE *farg)
*    - x is the variable array
*    - num_x is the lenght of x
*    - ycalc is the result array (see nret below)
*    - num_ycalc is the length of ycalc
*    - farg is a pointer to additional arguments (can be any type, usually 
*      a structure containing a number of parameters)
*    - iflag is an integer return value. iflag < 0 is interpretted as an error
*
* - n_ret is size of the return value from func.  specifying this allows the ycalc
*   array to be generated automatically with the correct size, and allows 
*   the residual to be computed correclty.  
*     0 = same as xdat (num_x)
*    -1 = 1 element
*    -2 = 2 element etc...
*     1 = same as xdat +1 
*     2 = same as xdat +2  etc..
*
* - farg is a pointer to the function arguments
*
* - fname: (optional) string name of the fitting function
*   pass NULL if you want to ignore this
* 
* Returns
* -------
* - A new 'FitData' structure (see typdef of FitData_t in header file)
*
******************************************************************************/
FitData_t *init_fit(Function *func, int n_ret, void *farg, char *fname)
{
    FitData_t *fit;
    fit = new_array(1,FitData_t);
    if (fit==NULL) return(FAILURE);

    // function stuff
    fit->func = NULL;
    if (func != NULL) fit->func = func;
    fit->n_ret = n_ret;  
    fit->farg  = NULL;
    if (farg != NULL) fit->farg = farg;
    fit->fname = NULL;
    if (fname != NULL){
        //if (fit->fname != NULL) free(fit->fname);
        fit->fname = copy_string(fname);
    }

    // data to be fit  
    fit->n_dat         = 0;         
    fit->xdat          = NULL;
    fit->ydat          = NULL;
    fit->yerr          = NULL;

    // fit params
    fit->n_params      = 0;
    fit->del           = NULL;
    fit->del_err       = NULL;
    fit->dmin          = NULL;
    fit->dmax          = NULL;
    fit->float_idx     = NULL;
    fit->param_map     = NULL;  

    // parameters set/returned by do_fit 
    fit->n_evals       = 0;
    fit->n_free        = 0;
    fit->chi_sqr       = 0.0;
    fit->red_chi_sqr   = 0.0;

    // size and results of calc/fit  
    fit->n_ycalc       = 0;
    fit->ycalc         = NULL;               
    fit->resid         = NULL;              

    // flags etc... 
    fit->check_plims   = TRUE;
    fit->calc_resid    = TRUE;

    return(fit);
}

/******************************************************************************
* clear_fit()
* Clear all allocated memory associated with a fit data structure
*
* Parameters
* ---------
* - fit: pointer to a FitData structure. 
*
* Returns
* -------
* - SUCCESS/FAILURE
*
* Notes
* -----
* This frees all allocated memory.  It does not free memory associated
* with fit->xdat, fit->ydat or fit->yerr.  Those are the callers 
* responsibilty.  
******************************************************************************/
int clear_fit(FitData_t *fit)
{
    // free calc and resid
    if (fit->ycalc != NULL){
        free(fit->ycalc);
        fit->ycalc = NULL;
    }
    if (fit->resid != NULL){
        free(fit->resid);
        fit->resid = NULL;
    }

    // free params
    clear_fit_params(fit);

    // free function fname 
    free(fit->fname); fit->fname = NULL;

    //free(fit); 
    return(SUCCESS);
}

/******************************************************************************
* clear_fit_params()
* Free memory that was created for fit parameters
*
* Parameters
* ---------
* - fit: pointer to a FitData structure. 
*
* Returns
* -------
* - SUCCESS / FAILURE
*
******************************************************************************/
int clear_fit_params(FitData_t *fit)
{
    int j = 0;
    ParamMap_t *param_map;

    // free parameter arrays
    fit->n_params = 0;
    free(fit->del); fit->del = NULL;
    free(fit->del_err); fit->del_err = NULL;
    free(fit->dmax); fit->dmax = NULL;
    free(fit->dmin); fit->dmin = NULL;
    free(fit->float_idx); fit->float_idx = NULL;

    // free param map
    param_map = fit->param_map;
    for (j=0;j<fit->n_params; j++){
        if (param_map[j].ptr != NULL){
            free(param_map[j].ptr);
            free(param_map[j].ptr_val);
            free(param_map[j].scale);
            param_map[j].ptr  = NULL;
            param_map[j].ptr_val = NULL;
            param_map[j].scale = NULL;
            param_map[j].n_ptr = 0;
        }
    }
    free(param_map);
    fit->param_map = NULL;

    return (SUCCESS);
}

/*****************************************************************************/

///////////////////////////////////////////////////////////////////////////////
// fit parameters and variable links
///////////////////////////////////////////////////////////////////////////////

/******************************************************************************
* new_fit_param()
* Add fitting parameters to the fit structure
*
* Parameters
* ---------
* - fit: pointer to a FitData structure. 
* - param_idx: index of the fit parameter to update 
*   - if this is negative a new fit parameter
*     is added to the end of the list
*   - if this corresponds to a current fit parameter index
*     number, that parameter is reinitialized
*
* Returns
* -------
* - Index of parameter (new or reintilized).  
* - If less than zero error.
*
* Notes
* -----
* This creates/initializes (or re-initializes) a fit parameter.
* Use set_fit_param() to update fit param values.
*
* This also makes a corresponding entry in the param_map array.
* However the param_map entry for this parameter is initialized
* with NULL values.  Use link_fit_var() to link a model variable 
* to one of the fit parameters.
*
* Note when a parameter is reinitialized the param_map for the
* parameter is blown away and all link information is lost for 
* that parameter.  
*
******************************************************************************/
int new_fit_param(FitData_t *fit, int param_idx )
{
    if (fit==NULL) return(-1);
    if ( param_idx > fit->n_params - 1) {
        buff_print("Error parameter index out of range\n");
        return(-1);
    }
    // if param_idx is less than zero add a new 
    // param to the end of the list
    if (param_idx < 0) {
        param_idx = fit->n_params;
    } 

    // if the parameter doesnt exist add a new one
    if (param_idx == fit->n_params){
        fit->n_params ++;
        fit->del         = mod_array(fit->del, fit->n_params, double);
        fit->del_err     = mod_array(fit->del_err, fit->n_params, double);
        fit->dmin        = mod_array(fit->dmin, fit->n_params, double);
        fit->dmax        = mod_array(fit->dmax, fit->n_params, double);
        fit->float_idx   = mod_array(fit->float_idx, fit->n_params, int);
        //
        fit->del[param_idx]        = 0.0;
        fit->del_err[param_idx]    = 0.0;
        fit->dmin[param_idx]       = 0.0;
        fit->dmax[param_idx]       = 0.0;
        fit->float_idx[param_idx]  = TRUE;
        //
        fit->param_map = mod_array(fit->param_map, fit->n_params, ParamMap_t);
        fit->param_map[param_idx].n_ptr   = 0; 
        fit->param_map[param_idx].ptr     = NULL;
        fit->param_map[param_idx].ptr_val = NULL;
        fit->param_map[param_idx].scale   = NULL;
        //
    } else {
        // else if it already exists blow it away and re-init
        fit->del[param_idx]        = 0.0;
        fit->del_err[param_idx]    = 0.0;
        fit->dmin[param_idx]       = 0.0;
        fit->dmax[param_idx]       = 0.0;
        fit->float_idx[param_idx]  = TRUE;
        //
        free(fit->param_map[param_idx].ptr);
        free(fit->param_map[param_idx].ptr_val);
        free(fit->param_map[param_idx].scale);
        //
        fit->param_map[param_idx].n_ptr   = 0; 
        fit->param_map[param_idx].ptr     = NULL;
        fit->param_map[param_idx].ptr_val = NULL;
        fit->param_map[param_idx].scale   = NULL;
    }
    return(param_idx);
}

/******************************************************************************
* set_fit_param()
* Set fit parameter val/min/max/float
* 
* Parameters
* ---------
* - fit: pointer to a FitData structure. 
* - param_idx: the fit parameter index to be updated
*   - if this is negative a new fit parameter
*     is added to the end of the list
* - del is the initial value of the fit parameter
* - dmin is the min value of del when limit checking is enables
* - dmax is the max value of del when limit checking is enables
* - flt is TRUE/FALSE flag.  
*   - TRUE allows the parameter to float during a fit
*   - FALSE fixes the parameter at its current value during a fit
*   
* Returns
* -------
* - Index of parameter.  
* - If less than zero error.
*
* Notes
* -----
* See notes for new_fit_param()
*
******************************************************************************/
int set_fit_param(FitData_t *fit, int param_idx, double del, double dmin, 
                  double dmax, int flt)
{
    if (fit==NULL) return(-1);
    if ( param_idx > fit->n_params - 1)  {
        buff_print("Error parameter index out of range\n");
        return(-1);
    }
    // create a new param if idx is negative
    if (param_idx < 0){
        param_idx = new_fit_param(fit, param_idx);
        if (param_idx < 0) return (param_idx);
    }
    fit->del[param_idx]        = del;
    fit->del_err[param_idx]    = 0.0;
    fit->dmin[param_idx]       = dmin;
    fit->dmax[param_idx]       = dmax;
    fit->float_idx[param_idx]  = flt;
    return(param_idx);
}

/******************************************************************************
* link_fit_var()
* Link function variables with fitting parameters
*
* Parameters
* ---------
* - fit: pointer to a FitData structure. 
* - param_idx: fit parameter index 
*   - if this is negative a new fit parameter
*     is added to the end of the list
* - var_ptr: pointer to the model variable (must be pointer to double)
* - scale: scale factor
* - reset: if this flag is TRUE then the fit parameter data and parameter
*   map will be re-initialized for the specified parameter (if it already exists).
*   Otherwise the var_ptr is added to the end of the existing param_map 
*   for the specified parameter. 
*
* Returns
* -------
* - Index of parameter.  
* - If less than zero error.
*
* Notes
* -----
* See notes at the top of this file
*
******************************************************************************/
int link_fit_var(FitData_t *fit, int param_idx, double *var_ptr, 
                 double scale, int reset)
{
    int j, k, n, nn;
    ParamMap_t *pmap;

    if (fit==NULL) return(-1);
    if ( param_idx > fit->n_params - 1)  {
        buff_print("Error parameter index out of range\n");
        return(-1);
    }
    // create a new param if idx is negative
    // or reset if it exists and reset == TRUE
    if (param_idx < 0){
        param_idx = new_fit_param(fit, param_idx);
        if (param_idx < 0) return (param_idx);
    } else if (reset == TRUE) {
        // reinit
        param_idx = new_fit_param(fit, param_idx );
        if (param_idx < 0) return (param_idx);
    }

    // grab param_map
    pmap = fit->param_map;

    // see if var_ptr is already in the map.
    // ie may not have duplicate entries
    n = fit->n_params;
    for (j=0; j < n; j++){
        nn = pmap[j].n_ptr;
        for (k=0; k < nn; k++){
            if (pmap[j].ptr[k] == var_ptr){
                buff_print("Error variable already exists in parameter map\n");
                buff_print("Fit parameter %i, link number %i\n",j,k);
                return (-1);
            }
        }
    }

    // create or expand param_map arrays
    n =  pmap[param_idx].n_ptr;
    if (n == 0){
        pmap[param_idx].ptr     = new_array(1,double *);
        pmap[param_idx].ptr_val = new_array(1,double );
        pmap[param_idx].scale   = new_array(1,double );
    } else {
        pmap[param_idx].ptr     = mod_array(pmap[param_idx].ptr, n+1, double *);
        pmap[param_idx].ptr_val = mod_array(pmap[param_idx].ptr_val, n+1, double);
        pmap[param_idx].scale   = mod_array(pmap[param_idx].scale, n+1, double);
    }
    pmap[param_idx].n_ptr       = n+1;
    pmap[param_idx].ptr[0]      = var_ptr;
    pmap[param_idx].ptr_val[0]  = *var_ptr;
    pmap[param_idx].scale[0]    = scale;

    return (param_idx);
}


/******************************************************************************
* accept_fit_params()
* Update variable values and reset del's to zero
*
* Parameters
* ---------
* - fit: pointer to a FitData structure. 
*
* Returns
* -------
* - SUCCESS / FAILURE
*
* Notes
* -----
* This will update the variable values from the parameters:
*
*   variable_i = variable_i_0 + scale_i * del_j
*
* Then look through the param map and reset all 
*   del_j = 0 
*   varaible_i_0 = variable_i
******************************************************************************/
int accept_fit_params(FitData_t *fit)
{
    int j, k;

    // update variable values
    if (_update_fit_vars(fit)==FAILURE) return (FAILURE);

    // update param map with the current variable values
    // clear the del's
    for (j = 0; j < fit->n_params; j++){
        fit->del[j] = 0.0;
        fit->del_err[j] = 0.0;
        for (k=0; k < fit->param_map[j].n_ptr; k++){
            fit->param_map[j].ptr_val[k] = *(fit->param_map[j].ptr[k]) ; 
        }
    }
    fit->n_evals       = 0;
    fit->chi_sqr       = 0.0;
    fit->red_chi_sqr   = 0.0;

    return (SUCCESS);
}

/*****************************************************************************/

///////////////////////////////////////////////////////////////////////////////
// fit data
///////////////////////////////////////////////////////////////////////////////

/******************************************************************************
* update_fit_data()
* Update the data arrays in fit.  
*
* Parameters
* ---------
* - fit: pointer to a FitData structure. 
* - n_dat is the number of data points
* - xdat independant variables (length n_dat)
* - ydat dependant variables / data (length n_dat or NULL)
* - yerr corresponding error bars (length n_dat or NULL)
* 
* Returns
* -------
* - SUCCESS/FAILURE
*
* Notes
* -----
* These arrays must be provided by the user alreay intitialized. These arrays
* will not be modified or deleted by this module.  
*
******************************************************************************/
int update_fit_data(FitData_t *fit, int n_dat, double  *xdat, 
                    double  *ydat, double  *yerr)
{
    
    if (fit==NULL) return(FAILURE);
    if (n_dat > 0){
        fit->n_dat = n_dat;
    } else {
        fit->n_dat = 0;
    }
    fit->xdat  = xdat;
    fit->ydat  = ydat;
    fit->yerr  = yerr;
    return(SUCCESS);
}
/******************************************************************************

///////////////////////////////////////////////////////////////////////////////
// run a fit / calc
///////////////////////////////////////////////////////////////////////////////

/******************************************************************************
* do_fit()
* Execute a fit
*
* Parameters
* ---------
* - fit: pointer to a FitData structure. 
* - fit_flag = TRUE do the fit
*   fit_flag = FALSE no fit, and no resid is calc, just a function execution
*
* Returns
* -------
* - SUCCESS/FAILURE
*          
* Notes
* -----
* This will execult a fit (or calc). 
*
* Note that the fit->ycalc and fit->residual arrays will be generated 
* before the fit/calc.  If these arrays already exist the memory will be 
* freed before new arrays are generated (see _update_fit_ycalc()). Also 
* note that these arrays will be freed when you use clear_fit().  If you 
* want to keep an older copy of these arrays see get_fit_ycalc() and 
* get_fit_residual()
*
* Variables will retain original values...
* 
* The error bars (standard deviations) of the fitted parameters are 
* scaled by chi_squared.  These can be interepreted as 1*sigma values 
* for the del parameters.  
*
* Todo
* ------
* Make sure we are catching errors from lmdif and fiterr correctly.
*
******************************************************************************/
int do_fit( FitData_t *fit, int fit_flag)
{
    int     info, iflag, j, k, ret;
    int     check_plims;
    double  toler = 1.0e-9;     /* fitting tolerance */
    double  denom;
    double  *free_params=NULL;
    double  *free_param_errs=NULL;
    double  *correl=NULL;
    int     *ibad=NULL;

    if (fit==NULL) return(FAILURE);

    // see if there are any free params
    if (fit_flag == TRUE){
        fit->n_free = 0;
        for (j=0; j < fit->n_params; j++){
            if (fit->float_idx[j] == 1){
                fit->n_free = fit->n_free + 1;
            }
        }
        if (fit->n_free == 0 ) fit_flag = FALSE;
    }

    // check fit_flag
    if (fit_flag == TRUE){
        fit->calc_resid = TRUE;
    } else {
        fit->calc_resid = FALSE;
    }

    // set up: 
    fit->n_evals = 0;
    fit->chi_sqr = 0.0;
    fit->red_chi_sqr = 0.0;
    if (_update_fit_ycalc(fit) == FAILURE) return(FAILURE);

    // need at least one result (?)
    if (fit->n_ycalc < 1){ 
        buff_print("Error: length of result vector less than 1\n");
        return(FAILURE); 
    }
    
    // if running a fit make the free_params array etc..
    if (fit_flag == TRUE){
        free_params     = new_array(fit->n_free, double);
        free_param_errs = new_array(fit->n_free, double);
        correl          = new_array((fit->n_free)*(fit->n_free), double);
        ibad            = new_array(fit->n_free, int);
        for (j= 0; j< (fit->n_free)*(fit->n_free); j++){
            correl[j]  = 0.0;
        }
        // update the free params array
        k = 0;
        for (j=0; j < fit->n_params; j++){
            if (fit->float_idx[j] == 1){
                free_params[k]     = fit->del[j];
                free_param_errs[k] = 0.0;
                ibad[k]            = 0;
                k++;
            }
        }
    } 

    // call the function once (ignore param limits)
    // then put function variable values back to original
    // ie _func_call() changes all the linked variable values
    check_plims      = fit->check_plims;
    fit->check_plims = FALSE;
    iflag = _func_call( fit->n_ycalc,
                        fit->n_free, 
                        free_params, 
                        fit->resid, 
                        fit);
    fit->n_evals = 1;
    ret = _reset_fit_vars(fit);
    fit->check_plims = check_plims;

    // if all is good do the fit 
    if ( (iflag >= 0) && (fit_flag == TRUE) ) {

        //buff_print( "# fitting ...\n" ); 
        fit->n_evals = 0;
        fit->calc_resid = TRUE;
        fit->n_evals =  lmfit( (*_func_call), 
                                fit->n_ycalc, 
                                fit->n_free, 
                                free_params, 
                                fit->resid, 
                                fit, 
                                toler, &info);
        ret = _reset_fit_vars(fit);

        //buff_print( "# done.   %d function evaluations\n", fit->n_evals);
        // note if info <0 there was a problem computing the function.
        // if its 0 there was some input problem to lmdif
        // if its 1-3 then ended ok.  if its 4-8 then there is an issue
        if(info == 0) buff_print( "# Return message from lmdif:\n# %s\n\n", lm_info(info) );
        if(info > 4) buff_print( "# Return message from lmdif:\n# %s\n\n", lm_info(info) );
        if (info < 0) {
            iflag = info;
            buff_print( "# Error computing model function in lmdif\n\n");
        }

        // calc chi_sqr 
        fit->chi_sqr = sum_squares(fit->resid, fit->n_ycalc );
        denom = ( (double)(fit->n_ycalc) - (double)(fit->n_free) );
        if (denom != 0.) {
            fit->red_chi_sqr = (fit->chi_sqr) / denom;
        } else {
            fit->red_chi_sqr = 0.;
        }
        
        // calc errors 
        // note errors are scaled by chi_square value
        fit->check_plims = FALSE;
        info = fiterr( (*_func_call), 
                        fit->n_ycalc, 
                        fit->n_free, 
                        free_params, 
                        fit->resid, 
                        fit, 
                        free_param_errs, 
                        correl, ibad); 
        ret = _reset_fit_vars(fit);
        fit->check_plims = check_plims;

        // check the error result
        if (info == 0) {  
            for (j = 0 ; j <  fit->n_free; j++ ) { 
                free_param_errs[j] *= sqrt(fabs(fit->chi_sqr));
            }
        } else {
            buff_print( "# Can't determine uncertainties\n");
            for (j = 0 ; j <  fit->n_free; j++ ) free_param_errs[j] = 0.0;
            if (info == 1){
                buff_print( "# Unable to compute covarience matrix\n");
                for (j = 0 ; j <  fit->n_free; j++ ) {
                    if (ibad[j] == 1){
                        buff_print( "# Parameter: %i is suspect\n", j);
                    }
                }
            } else if (info < 0) {
                iflag = info;
                buff_print( "# Problem executing the function\n");
            }
        } 
        // update del_err's
        k = 0;
        for (j=0; j < fit->n_params; j++){
            if (fit->float_idx[j] == 1.0){
                fit->del_err[j] = free_param_errs[k];
                k++;
            } else {
                fit->del_err[j] = 0.0;
            }
        } 
        // end error stuff
    }

    // free mallocd mem used here
    if (fit_flag == TRUE){
        free(free_params);
        free(free_param_errs);
        free(correl);
        free(ibad); 
    }

    if (iflag < 0) return (FAILURE);
    return(SUCCESS);

}
/*****************************************************************************/

///////////////////////////////////////////////////////////////////////////////
// Output   
///////////////////////////////////////////////////////////////////////////////

/******************************************************************************
* get_fit_stats()
* Return a new array with fit stats
*
* Parameters
* ---------
* - fit: pointer to a FitData structure. 
*
* Returns
* -------
* Array of fit statitics (double array)
* fit_stats[0] = chi_sqr;
* fit_stats[1] = red_chi_sqr;
* fit_stats[2] = n_evals;
* fit_stats[3] = n_dat;
* fit_stats[4] = n_params;
* fit_stats[5] = n_free;
* fit_stats[6] = n_ycalc;
* 
* Notes
* -----
* The array is newly allocated memory.  
* The user is responsible for freeing 
******************************************************************************/
double *get_fit_stats(FitData_t *fit)
{
    double *fit_stats;

    if (fit == NULL) return(NULL);
    fit_stats = new_array(7, double);
    fit_stats[0] = (double )fit->chi_sqr;
    fit_stats[1] = (double )fit->red_chi_sqr;
    fit_stats[2] = (double )fit->n_evals;
    fit_stats[3] = (double )fit->n_dat;
    fit_stats[4] = (double )fit->n_params;
    fit_stats[5] = (double )fit->n_free;
    fit_stats[6] = (double )fit->n_ycalc;
    return(fit_stats);
}

/******************************************************************************
* get_fit_ycalc()
* This rets a pointer to array of calculated values
*
* Parameters
* ---------
* - fit: pointer to a FitData structure. 
* - mk_copy: flag (TRUE/FALSE).
*   - if TRUE a new copy is is generated
*   - if FALSE just return a pointer to ycalc help by fit
*
* Returns
* -------
* Array of calculated values (length fit->n_ycalc)
* 
* Notes
* -----
* If you return a copy the user is responsible for freeing the memory
* If you do not return a copy, the array will go away when fit is cleared...
*
******************************************************************************/
double *get_fit_ycalc(FitData_t *fit, int mk_copy)
{
    double *fit_ycalc;
    int     j;

    if (fit == NULL) return(NULL);
    if (fit->ycalc == NULL) return (NULL);

    if (mk_copy==TRUE){
        fit_ycalc = new_array(fit->n_ycalc, double);
        for (j = 0; j< fit->n_ycalc; j++){
            fit_ycalc[j] = fit->ycalc[j];
        }
    } else {
        fit_ycalc  = fit->ycalc;
    }
    return(fit_ycalc);
}

/******************************************************************************
* get_fit_resid()
* This rets a pointer to residual array 
*
* Parameters
* ---------
* - fit: pointer to a FitData structure. 
* - mk_copy: flag (TRUE/FALSE).
*   - if TRUE a new copy is is generated
*   - if FALSE just return a pointer to ycalc help by fit
*
* Returns
* -------
* Array of residual values (length fit->n_ycalc)
* 
* Notes
* -----
* If you return a copy the user is responsible for freeing the memory
* If you do not return a copy, the array will go away when fit is cleared...
*
******************************************************************************/
double *get_fit_resid(FitData_t *fit, int mk_copy)
{
    double *fit_resid;
    int     j;

    if (fit == NULL) return(NULL);
    if (fit->resid == NULL) return (NULL);

    if (mk_copy==TRUE){
        fit_resid = new_array(fit->n_ycalc, double);
        for (j = 0; j< fit->n_ycalc; j++){
            fit_resid[j] = fit->resid[j];
        }
    } else {
        fit_resid  = fit->resid;
    }
    return(fit_resid);
}

/******************************************************************************
* get_fit_params()
* This rets a pointer to fit parameters array 
*
* Parameters
* ---------
* - fit: pointer to a FitData structure. 
* - mk_copy: flag (TRUE/FALSE).
*   - if TRUE a new copy is is generated
*   - if FALSE just return a pointer to ycalc help by fit
*
* Returns
* -------
* Array of del values (length fit->n_params)
* 
* Notes
* -----
* If you return a copy the user is responsible for freeing the memory
* If you do not return a copy, the array will go away when fit is cleared...
*
*******************************************************************************/
double *get_fit_params(FitData_t *fit, int mk_copy)
{
    double *fit_params;
    int     j;

    if (fit == NULL) return(NULL);
    if (fit->del == NULL) return (NULL);

    if (mk_copy==TRUE){
        fit_params = new_array(fit->n_params, double);
        for (j = 0; j< fit->n_params; j++){
            fit_params[j] = fit->del[j];
        }
    } else {
        fit_params  = fit->del;
    }
    return(fit_params);
}

/******************************************************************************
* get_fit_param_errs()
* This rets a pointer to fit parameter errors array 
*
* Parameters
* ---------
* - fit: pointer to a FitData structure. 
* - mk_copy: flag (TRUE/FALSE).
*   - if TRUE a new copy is is generated
*   - if FALSE just return a pointer to ycalc help by fit
*
* Returns
* -------
* Array of del_err values (length fit->n_params)
* 
* Notes
* -----
* If you return a copy the user is responsible for freeing the memory
* If you do not return a copy, the array will go away when fit is cleared...
*
******************************************************************************/
double *get_fit_param_errs(FitData_t *fit, int mk_copy)
{
    double *fit_param_errs;
    int     j;

    if (fit == NULL) return(NULL);
    if (fit->del_err == NULL) return (NULL);

    if (mk_copy==TRUE){
        fit_param_errs = new_array(fit->n_params, double);
        for (j = 0; j< fit->n_params; j++){
            fit_param_errs[j] = fit->del_err[j];
        }
    } else {
        fit_param_errs  = fit->del_err;
    }
    return(fit_param_errs);
}   


/******************************************************************************
* show_fit()
* Show fit results
*
* Parameters
* ---------
* - fit data structure
* 
* Outputs
* -------
- None
*
* Notes
* ------
* Use for debugging
******************************************************************************/
void show_fit(FitData_t *fit)
{
    int j, n, k;

    if (fit == NULL) return;

    buff_print("Fit Structure\n----------\n");
    n = (fit->n_params);
    buff_print("Fit parameters\n");
    if (n == 0){
        buff_print(" *** No fitting parameters defined ***\n");
    } else {
        for (j=0; j < n; j++){
            buff_print("******\n");
            buff_print("Fit parameter %-2d\n", j+1);
            buff_print("del[%-2d] = %-6.3g  +/-  %-6.3g ", 
                       j, 
                       fit->del[j], 
                       fit->del_err[j]); 
            buff_print(" ( dmin = %-5.3g, dmax = %-5.3g, float = %1d, n_link = %d )\n",
                        fit->dmin[j], fit->dmax[j], 
                        fit->float_idx[j],
                        fit->param_map[j].n_ptr);
            buff_print("Parameter links\n"); 
            for (k=0;k<fit->param_map[j].n_ptr;k++){
                buff_print("  * link %i  val = %g + %g x %g \n", k+1,
                            fit->param_map[j].ptr_val[k],
                            fit->param_map[j].scale[k],
                            fit->del[j] );
            }
        }
    }
    buff_print("******\n");
    buff_print("\nFit Statistics\n");
    buff_print("chi_square         = %g\n", fit->chi_sqr);
    buff_print("red_chi_squ        = %g\n", fit->red_chi_sqr);
    buff_print("n_evals            = %d\n", fit->n_evals );
    buff_print("n_dat              = %d\n", fit->n_dat);
    buff_print("n_params           = %d\n", fit->n_params);
    buff_print("n_free             = %d\n", fit->n_free );
    buff_print("n_ycalc            = %d\n", fit->n_ycalc );       

    buff_print("\n\n");
}

/*****************************************************************************/

///////////////////////////////////////////////////////////////////////////////
// Local (utility) functions 
///////////////////////////////////////////////////////////////////////////////

/******************************************************************************
* _update_fit_ycalc()
* Called from do_fit to clear/init ycalc and residual
*
* Parameters
* ---------
* - fit: pointer to a FitData structure. 
*
* Returns
* -------
* - SUCCESS / FAILURE
*
* Notes
* -----
* When the ycalc (ie result) arrays are generated we use 
* fit->n_ret which reflects the size of ret value from the function:
*   0 = same as fit->n_dat 
*  -1 = 1 element
*  -2 = 2 element etc...
*   1 = same as n_dat +1 
*   2 = same as n_dat +2 etc...
* and fit->n_dat is the length of fit->xdat (if not NULL), 
* fit->ydat (if not NULL), and fit->yerr (if not NULL). 
* fit->n_dat=0 is valid.  
* 
* Therefore the fit->ycalc array (and fit->residual array) are generated 
* using a length fit->n_ycalc which is 
*    fit->n_ycalc = fit->n_dat     : if fit->n_ret = 0 
*    fit->n_ycalc = fit->n_dat + 1 : if fit->n_ret = 1 etc. 
*    fit->n_ycalc = 1              : if fit->n_ret = -1 etc. 
* 
* If fit->n_ycalc < 1 this returns an error.
*
* Make sure the n_ret value is set correctly and the model function 
* handles this correclty!
*
* Also note that this function will free the memory associated with 
* fit->ycalc and fit->residual before generating new arrays.  Therefore
* if you wanted to keep the old arrays make sure you make a copy before 
* calling this.
*
* The fit->ycalc and fit->residual arrays are intialized to zeros.
******************************************************************************/
int _update_fit_ycalc(FitData_t *fit)
{
    int j;

    if (fit == NULL) return(FAILURE);

    // clear old arrays
    if (fit->ycalc != NULL){
        free(fit->ycalc);
        fit->ycalc = NULL;
    }
    if (fit->resid != NULL){
        free(fit->resid);
        fit->resid = NULL;
    }
    // compute new fit->n_ycalc
    if (fit->n_ret == 0){
        fit->n_ycalc = fit->n_dat;
    } else if (fit->n_ret > 0){
        fit->n_ycalc = fit->n_dat + fit->n_ret;
    } else {
        fit->n_ycalc = abs(fit->n_ret);
    }
    if (fit->n_ycalc < 1){
        fit->n_ycalc = 0;
        return (FAILURE);
    }

    // create new calc arrays
    fit->ycalc = new_array(fit->n_ycalc, double);
    for (j=0; j < fit->n_ycalc; j++){
        fit->ycalc[j] = 0.0;
    }
    if (fit->calc_resid == TRUE){
        fit->resid = new_array(fit->n_ycalc, double);
        for (j=0; j < fit->n_ycalc; j++){
            fit->resid[j] = 0.0;
        }
    }
    return(SUCCESS);
}

/******************************************************************************
* _update_fit_vars()
* Calc fit variable values from params values
*
* Parameters
* ---------
* - fit: pointer to a FitData structure. 
*
* Returns
* -------
* - SUCCESS / FAILURE
*
* Notes
* -----
* This is called from _func_call() to update the variable values
* from the parameters. Variable values are calculated as:
*
*   variable_i = variable_i_0 + scale_i * del_j
*
* The original variable values are stored and can be restored using
* _reset_fit_vars()
*
******************************************************************************/
int _update_fit_vars(FitData_t *fit)
{
    int j, k;
    double val = 0.0;
    ParamMap_t *param_map;

    param_map = fit->param_map;
    if (param_map == NULL) return(SUCCESS);

    // calculate new paramter values
    for (j = 0; j < fit->n_params; j++){
        for (k=0; k < param_map[j].n_ptr; k++){
            val = param_map[j].ptr_val[k] + param_map[j].scale[k] * fit->del[j];
            *(param_map[j].ptr[k]) = val; 
        }
    }
    return(SUCCESS);
}

/******************************************************************************
* _reset_fit_vars()
* Reset fit variables to thier original values
*
* Parameters
* ---------
* - fit: pointer to a FitData structure. 
*
* Returns
* -------
* - SUCCESS / FAILURE
*
* Notes
* -----
* This is called from do_fit() to reset the variables to thier original 
* values.  This does not modify any of the fit parameters (del values).  
*
******************************************************************************/
int _reset_fit_vars(FitData_t *fit)
{
    int j, k;
    ParamMap_t *param_map;

    param_map = fit->param_map;
    if (param_map == NULL) return(SUCCESS);

    // reset variables to thier original values
    for (j = 0; j < fit->n_params; j++){
        for (k=0; k < param_map[j].n_ptr; k++){
            *(param_map[j].ptr[k]) = param_map[j].ptr_val[k] ; 
        }
    }
    return(SUCCESS);
}

/******************************************************************************
* _func_call()
* Function call for fitting
*
* Parameters
* ---------
* - num_ycalc is the length of the residual array.
* - num_free_params is the length of the free_params array
* - free_params is the array of parameters to be adjusted in the fit 
* - resid is the residual array that is computed here.  This is the 
*   target vector for minimization in the least-squares routine. 
* - fit_data is pointer to the fit (FitData) data structure.  
*
* Returns
* -------
* - iflag integer return code from fit->func.  
*   return iflag < 0 for func error.
*
* Notes
* -----
* This computes the residual used by lmfit.  The residual is 
* computed from the output of the model function fit->func and the 
* data fit->ydat (if appropriate). 
* 
* The model function fit->func is called here, and we assume a 
* prototype of:
*    iflag = func(double *x, int num_x, double *ycalc, int num_ycalc, void *farg)
*    - x is the array of independant variables (length num_x)
*    - ycalc is an array for the resulting calc (length num_ycalc)
*      Note that ycalc may differ in length from x.  see _update_fit_ycalc().
*      and notes below.  
*    - farg is a pointer to additional function arguments (variables and
*      and other data specific to the function). This will generally be
*      a user defined structure.  
*
* Residual calculation:
* As noted above the model function updates the array fit->ycalc
* which has a length fit->n_ycalc. This is array is created by
* _update_fit_ycalc() which is called from do_fit() (ie we assume
* all the arrays are already created and are the correct size)
*
* The fit->ycalc array (and fit->residual array) are generated 
* using a length fit->n_ycalc which is 
*    fit->n_ycalc = fit->n_dat     : if fit->n_ret = 0 
*    fit->n_ycalc = fit->n_dat + 1 : if fit->n_ret = 1 etc. 
*    fit->n_ycalc = 1              : if fit->n_ret = -1 etc. 
* where fit->n_dat is the length of fit->xdat (if not NULL), 
* fit->ydat (if not NULL), and fit->yerr (if not NULL). Note 
* that fit->n_dat = 0 is valid.  
* 
* - If fit->ydat is NULL or fit->n_ret < 0 the residual are the 
*   ycalc values
*
* - If fit->n_ret == 0 the residual is computed from the differences between 
*   model and the data (and scaled by 1/sqrt(yerr) if yerr is not NULL)
*
* - If n_ret > 0, then the first fit->n_dat values are calc as above.  
*   The additional n_ret values are simply the additional ycalc values.  
*
* Other notes:
* Note this routine also does the limit checking on the parameters
* (if the fit->check_plims flag is set to TRUE).  These are hard wall
* limits.  If a fit parameter hits a limit the fit (and fit errors) 
* should be suspect since we will likely not be at a real local minimum.  
* Note if dmin = dmax for a parameter there will be no limit checking
* even in the fit->check_plims = TRUE
* 
* Note the arguments for this function need to be in this sequence 
* for lmfit... ie the do_fit() function calls lmfit with this function
* as the fcn argument.  
*  
******************************************************************************/
int _func_call( int  num_ycalc, int num_free_params, double *free_params, 
                double *resid, void  *fit_data)
{
    int         j, k, num_x, iflag=-1;
    double     *x, *ycalc, *ydat, *yerr ;
    FitData_t  *fit;
    Function   *func;

    fit   = fit_data;
    func  = fit->func;
    x     = fit->xdat; 
    num_x = fit->n_dat;
    ycalc = fit->ycalc; 
    ydat  = fit->ydat;
    yerr  = fit->yerr;

    // update the params array and check limits
    if (num_free_params > 0){
        k = 0;
        for (j=0; j < fit->n_params; j++){
            if (fit->float_idx[j] == 1){
                // check lims here, these are hard wall lims
                if(fit->check_plims == TRUE){
                    if(fit->dmin[j] != fit->dmax[j]){
                        if( free_params[k] < fit->dmin[j] ){
                            free_params[k] = fit->dmin[j];
                        } else if ( free_params[k] > fit->dmax[j] ){
                            free_params[k] = fit->dmax[j];
                        }
                    }
                }
                // update params
                fit->del[j] = free_params[k]; 
                k++;
            }
        }
    }

    // update the fit variable values (ie apply dels)
    _update_fit_vars(fit);

    // call the function
    iflag = (*func)( x, num_x, ycalc, num_ycalc, fit->farg );

    // this is a counter that keeps track of the number of 
    // of function calls.  there is also a nevals field
    // but this only gets updated at the end of an lmfit call
    // therefore we can use this to keep track of where we are 
    // during a fit (??)
    //fit->n_evals ++;

    // return on error
    if (iflag < 0){
        return(iflag);
    }

    // calc the residual
    if(fit->calc_resid == TRUE){
        // if ydat == NULL or fit->n_ret < 0
        // set the residual to the ycalc values
        if ( (fit->ydat == NULL) || (fit->n_ret < 0) ) {
            for(j=0; j < num_ycalc; j++){
                resid[j] = ycalc[j];
            }           
        } else {
            // compute the difference btwn model and data
            // note ydat has to be same size as x (ie num_x)
            for(j=0; j < num_x; j++){
                resid[j] = ycalc[j] - ydat[j];
                if (yerr != NULL){
                    if( yerr[j] != 0.0 )
                        resid[j] = resid[j] * (1 / sqrt( yerr[j]) );
                }
            }
        }
        // note the the extra bits in ycalc need to be wieghted resids already!
        // eg if the function also calcs a cost function...
        for (j = num_x; j < num_ycalc; j++){
            resid[j] = ycalc[j];
        }
    }
    return(CA_SUCCESS);
}
/*****************************************************************************/
